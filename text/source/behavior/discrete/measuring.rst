.. _speed-measurement:


Speed Measurement
-----------------

Baseline System
^^^^^^^^^^^^^^^

There are many applications where we need to model the interaction
between continuous behavior and discrete behavior.  For this section,
we'll look at techniques used to measure the speed of a rotating
shaft.  For our discussion here, we will reuse the :ref:`mechincal
example <mech-example>` we discussed previously in our discussion of
:ref:`basic-equations`:

.. literalinclude:: /ModelicaByExample/BasicEquations/RotationalSMD/SecondOrderSystem.mo
   :language: modelica
   :lines: 2-

Recall the solution for this model looks like this:

.. plot:: ../plots/SOSIP.py
   :include-source: no

In this case, we are simply plotting the solution that we computed.
But in a real system, we can't directly know the rotational velocity
of a shaft.  Instead, we have to measure it.  But measurement
introduces error and each measurement techniques introduce different
kinds of errors.  In this section, we'll look at how we can model
different kinds of measurement techniques.

Sample and Hold
^^^^^^^^^^^^^^^

The first type of measurement we will examine is a sample and hold
approach to measurement.  Some speed sensors have circuits for
measuring the rotational speed of the system.  But instead of
providing a continuous value for the speed, they sample it at a given
point in time and then store it somewhere.  This is called "sample and
hold".  The following model demonstrates how to implement and sample
and hold approach to measuring the angular velocity ``omega1``:

.. literalinclude:: /ModelicaByExample/DiscreteBehavior/SpeedMeasurement/SampleAndHold.mo
   :language: modelica
   :lines: 2-

.. index:: discrete

Note the presence of the ``discrete`` qualifier in the declaration of
``omega1_measured``.  This special qualifier indicates that the
specified variable does not have a continuous solution.  Instead, the
value of this variable will make (only) discrete jumps during the
simulation.  It is not required to include the ``discrete`` keyword
but it is useful because it provides additional information about the
intent of the model that the compiler can check (*e.g.,* making sure
we never request the derivative of that variable).

Let's us now examine the solution generated by this model:

.. plot:: ../plots/SampleAndHold.py
   :include-source: no

The important thing to note in the solution is how the measured value
is piecewise-constant.  This is because the value of
``omega1_measured`` is set only when the ``when`` clause becomes
active.  The ``sample`` function is a special built-in function that
first becomes true at the time indicated by the first argument (``0``
in this case) and then at regular intervals after that.  The duration
of these regular interfaces is indicated by the second argument
(``sample_time`` in this case).

Interval Measurement
^^^^^^^^^^^^^^^^^^^^

In the previous example, we weren't actually making any estimates for
the speed, we were simply reporting the value of the variable
``omega1`` only at specific times.  In other words, at the moment that
we sampled ``omega1`` our sample was completely accurate.  But by
"holding" our measured value (instead of continuing to track
``omega1``), we introduced some artifact in the measurement.

In the remaining examples, we will focus on techniques used to
estimate the speed of a rotating shaft.  In these cases, we will never
make direct use of the actual speed in our measurement.  Instead, we
will respond to events generated by the physical system and attempt to
use these events to reconstruct an estimate of the rotational speed.

The events that we will be responding to are generated by the discrete
elements attached to the spinning shaft.  For example, a typical way
to produce these events is to use a "tooth wheel encoder".  A tooth
wheel encoder include a gear on the rotating shaft.  On either side of
the gear, we place a light source and a light sensor.  As the gear
teeth pass in front of the light source, they block the light.  The
result is that the signal from the light sensor will include an
approximate square wave.  The leading edge of these square waves are
the events we will be responding to.

The first estimation method we will examine computes the speed of the
shaft by measuring the time interval that passes between events.
Knowing that these events are occur whenever the shaft has rotated by
an angle of :math:`\Delta\theta`, we can estimate the speed as:

.. math::

    \hat{\omega} = \frac{\Delta\theta}{\Delta t}

This technique for speed estimation can be represented in Modelica as:

.. literalinclude:: /ModelicaByExample/DiscreteBehavior/SpeedMeasurement/IntervalMeasure.mo
   :language: modelica
   :lines: 2-

where ``tooth_angle`` represents :math:`\Delta\theta`.  Note how
``tooth_angle`` is not something the user needs to specify.  Instead,
the user species the number of teeth using the ``teeth`` parameter.
The ``tooth_angle`` parameter is then computed using the value of
``teeth`` (note that while we have hand coded the value of :math:`pi`
here, we'll learn how to avoid this later in the book).

Let's take a look at the speed estimates provided by this approach:

.. plot:: ../plots/IntervalMeasure.py
   :include-source: no

There are two important properties of this estimation algorithm that
we can immediately see in these results.  The first is that the
estimate is unsigned.  In other words, we cannot tell from a device
like a tooth wheel encoder which **direction** the shaft is rotating.
Also, low speeds and speed reversals can degrade the accuracy of the
estimate significantly.  The results are also very sensitive the
number of teeth involved.  If we were to reduce the number of teeth
used in our encoder by setting ``teeth`` to 20, we'd get very
different results.

.. plot:: ../plots/IntervalMeasure_Coarse.py
   :include-source: no

To understand exactly why the measured signal is so inaccurate, it
helps to consider the following plot which shows how the angle,
``phi1`` compares to the angles associated with the adjacent teeth,
``next_phi`` and ``prev_phi``.

.. plot:: ../plots/IntervalMeasure_Coarse_phi.py
   :include-source: no

In this plot, we can clearly see how relatively low speeds and speed
reversals create irregular events that introduce significant
estimation error.

Counting
^^^^^^^^

The interval measuring technique mentioned above requires hardware
that can perform speed calculations on hardware interrupts.  Another
approach to estimating speed is the count how many events occur within
a given (fixed) time interval and use that as an estimate of speed.
Using this method, only the summation of events occurs when the events
occur and the calculations are deferred to a regularly scheduled
update.  The following method can be used to estimate speed using this
event counting approach:

